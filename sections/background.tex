\section{Background}
\label{sec:background}

\subsection{Linux Scheduling and sched\_ext}

Linux's default CFS (Completely Fair Scheduler)~\cite{wong2008cfs} implements a one-size-fits-all policy but is unoptimized for diverse workloads ranging from latency-sensitive web services to throughput-oriented batch jobs. While CFS ensures fairness through virtual runtime, modern systems require adaptive scheduling. sched\_ext~\cite{schedext2024}, introduced in Linux 6.12, enables dynamic loading of custom schedulers as eBPF programs without kernel modifications. Built on eBPF~\cite{mccanne1993bpf,gregg2019bpf}, which evolved from packet filtering into a general-purpose in-kernel VM, sched\_ext provides hooks for task enqueueing, CPU selection, load balancing, and idle management. The eBPF verifier ensures safety through static analysis, preventing crashes, invalid memory access, and infinite loops. Production schedulers like scx\_rusty (work-stealing), scx\_layered (hierarchical), and scx\_central (NUMA-aware) demonstrate eBPF can implement complex algorithms matching traditional schedulers with minimal overhead (<1\%).

\subsection{LLMs and Autonomous Agents}

Large language models have revolutionized code synthesis. Codex~\cite{chen2021codex} powers GitHub Copilot, while GPT-4~\cite{openai2023gpt4} and Claude~\cite{anthropic2024claude} generate complex systems code from natural language. Studies show developers using Copilot complete tasks 55\% faster. The years 2024-2025 mark an inflection point with autonomous agents like Claude Code, GitHub Copilot Workspace, and Devin performing complete software engineering workflows: understanding requirements, architecting solutions, implementing across files, writing tests, debugging, and iterating. However, these tools assist human developers rather than autonomously optimize system components. This gap presents an opportunity to leverage LLMs' semantic understanding to bridge application needs and kernel scheduler capabilities.

